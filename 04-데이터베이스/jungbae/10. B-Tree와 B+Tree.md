1. B-Tree란?

- B-Tree는 BinaryTree를 일반화한 개념으로, BinaryTree와는 다릅니다.
- B-Tree는 BalancedTree라는 뜻으로, 루트노드로부터 리프노드까지의 거리가 일정하며, 데이터가 정렬된 상태로 유지되어 있습니다.
- 한 노드에 2개 이상의 데이터(Key)가 들어갈 수 있으며 오름차순으로 정렬됩니다.
- 노드 하나 당, 자식 노드 2개 이상을 갖는 것이 가능하며 Key값을 이용해 찾고자 하는 데이터를 찾을 수 있습니다.
- 이때 내부 노드는 M/2 ~ M개의 자식을 가질 수 있습니다. 예를 들어 3차 B트리에서는 1~3개의 자식 노드를 가질 수 있습니다.
- B-tree에서 최소 key 수는 [M/2] -1 입니다 (올림합니다). 즉, 3차 Btree에서는 최소 1개의 Key를 가져야합니다. 

2. B-Tree의 삽입
- 상향식으로 진행하며, 트리가 비어있다면 Key를 삽입합니다.
- 트리가 비어있지 않다면 데이터를 넣을 리프노드를 탐색합니다.
- 리프노드에 데이터를 넣고 정렬합니다. 
- 이때, 적절한 상태가 아니라고 판단하면 분리합니다

(적절한 상태가 아닐 때)  
- 3차 B-Tree에서 자식 노드를 1~3개를 가질 수 있다면, 부모 노드는 1~2개의 Key를 가질 수 있을 것 입니다.
- 리프노드 혹은 중간(Branch Node)의 허용된 Key값보다 많아진다면, 그 부적절한 노드를 분리하여 Key의 median을 승급시킵니다.


3. B-Tree의 삭제
- 마찬가지로 상향식으로 리프노드부터 삭제합니다.
- 리프노드의 key를 삭제하더라도 최소 Key수를 만족한다면 삭제합니다.
- 삭제 후 최소 Key 수보다 적어졌다면 재조정합니다.

(재조정하는 경우)
- Key 수가 여유있는 형제의 지원을 받습니다. 이때 자식,부모 노드간의 교환이 일어날 수 있습니다.
- 형제노드에 받을 수 있는 Key가 없을 때는 부모노드로부터 Key를 가져옵니다.

4. B+Tree란?
- 이러한 B-Tree를 변형시킨 구조입니다.
- B-Tree와 달리 리프노드를 제외하고는 Key를 갖고있지 않기 때문에 하나의 블록에 더 많은 Key를 담아둘 수 있고, Tree의 높이가 낮아지는 장점이 있습니다.
- 풀 스캔 시, 리프노드에 대한 한 번의 선형 탐색만 하면 되기 때문에 B-Tree보다 빠릅니다.
- 같은 레벨의 노드에서는 DoubleLinkedList, 자식 노드는 SingleLinkedList를 사용합니다.