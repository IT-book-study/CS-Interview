# SQLAlchemy의 Session이 무엇이고 어떻게 동작하는지 설명하세요

- session은 데이터베이스에 연결하고 트랜잭션과 ORM 객체를 관리하는 객체입니다.

## Begin / Commit / Rollback
- 트랜잭션 시작과 커밋 롤백 기능을 session객체를 통해서 명시적으로 할 수 있습니다.
- session을 컨텍스트 매니저로 사용하면 with문을 이용해서 예외가 발생했을때 자동으로 트랜잭션을 rollback할 수 있습니다.

## 객체와 객체 상태
- session은 identity map이란 공간에 orm객체를 저장합니다.
- orm객체는 다음과 같은 상태를 갖습니다.
    - Transient: 세션에도 없고 데이터베이스에도 없는 상태
    - Pending: 세션에 add한 후 플러시를 기다리는 상태
    - Persistent: 세션에도 있고, 데이터베이스에 저장된 상태 
    - Deleted: 세션에서 삭제되었지만, 트랜잭션이 아직 처리가 되지 않은 상태 (Pending과 반대), 롤백되면 상태는 Persistent로 바뀝니다.
    - Detacted: 데이터베이스에 저장되었지만, 세션에는 없는 상태, 식별자는 존재하지만 데이터베이스와 연결할 수 없어서 이 객체는 일반적으로 사용가능하지만 “expired”된 속성이나 언로드된 속성을 불러올 수는 없습니다.


# Add
- 세션에 객체를 저장하는데 사용되는 메서드입니다.
- 새로 만든 객체는 transient상태가 되고, transient 객체들은 플러시 될때 한번에 데이터베이스에 INSERT 됩니다.
- detached된 객체도 add를 이용해 세션에 다시 연결할 수 있습니다.


# Delete
- 객체를 deleted상태로 마킹합니다.
- 플러시 될때 데이터베이스에서 삭제됩니다.

# Flush
- 변경사항을 데이터베이스로 내보내는 작업
- 명시적으로 플러시를 할 수 도 있지만, autuflush를 True로 하면 자동으로플러시 됩니다.
    - execute를 이용해서 sql 구문을 요청하는 경우
    - 객체를 refresh하는 경우
    - 객체의 속성을 lazy loading 하는 경우
- 옵션과 상관없이 트랜잭션을 커밋하거나, nested 트랜잭션을 시작하는 경우에는 항상 플러시됩니다.

# Expiring / Refreshing
> - ORM은 identity map을 이용해 로드된 객체들을 관리하고 있습니다.
> - 이를 통해 실질적으로 같은 레코드를 쿼리할때 업데이트 하지 않고 이전의 객체를 반환해줍니다.
> - => 이것은 트랜잭션이 격리되었다는 것을 가정하기 때문에 속성을 업데이트 하지않고 스킵하는 것입니다.
- expire: 객체의 속성을 만료시킵니다. 만료된 속성은 엑세스시 데이터베이스에서 로드하게 합니다.
  - 보통 트랜잭션이 종료하면 expire하는데, 다른 트랜잭션의 변경사항이 적용되게 하기 위함입니다.
- refresh: 객체의 속성을 만료시키고 바로 속성을 데이터베이스에서 다시 로드합니다.

