그래프에서 최단 경로를 구하는 방법은 여러가지가 존재합니다. 보통 가장 짧은 거리를 최단 거리, 그때의 경로를 경로를 최단 경로라고 합니다.  
거리의 기준은 가중그래프가 아닐 경우 경로상의 간선의 수가 적을 때를, 가중 그래프일 때는 가중치의 합이 작을수록 거리가 짧다고 이야기합니다.
  
이러한 최단경로를 구하는 알고리즘은 대표적으로 3개가 존재합니다.  

1. 다익스트라
- 한 노드에서 다른 모든 노드까지의 최단 경로를 구하는 알고리즘으로 그리디한 성질을 갖습니다.
- 그리디는 주해진 상황에서 최적의 해를 선택해 진행하는 방식으로 한 노드를 기준으로 가장 짧은 경로를 우선적으로 탐색합니다.

시간복잡도는 아래와 같습니다.
자바에서는 배열과 우선순위 큐로 이것을 구현할 수 있습니다. 우선순위 큐를 이용해 가중치가 작은 순서대로 정렬되어 최소 힙을 구합니다. (logN) * 간선의 수 (N) = (NlogN)  

2. 벨만-포드
- 한 노드에서 다른 노드까지의 최단 경로를 구하는 알고리즘으로 브루트 포스와 같은 성질을 갖습니다.
- 한 노드를 정한 뒤, 간선의 리스트를 이용해 최단 경로의 후보를 모두 탐색합니다.
  
시간복잡도는 아래와 같이 브루트포스 하기 때문에 (N * M) 이 됩니다.

```java
for (int i = 0; i < N-1; i++) {  // 노드의 수   
    for (int j = 0; j < M; j++) {  // 간선의 수
          
    }  
}  
```  
3. 플로이드-워셜
- 모든 노드에서 모든 노드까지의 최단 경로를 구하는 알고리즘으로 DP적인 성질을 갖습니다.
- 인접 행렬을 사용하며, 노드를 기준으로 동작하고 노드를 기준으로 모든 노드쌍을 살펴보기 때문에(N^2) N^3의 연산이 걸립니다.

```java
for (int k = 0; k < N; k++) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (dist[i][k] != Integer.MAX_VALUE && dist[k][j] != Integer.MAX_VALUE&& dist[i][k] + dist[k][j] < dist[i][j]) {
                dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }
}
```
바깥쪽 for문은 중간지점을 선택하고, 가운데 for문은 출발 노드를, 안쪽 for문은 도착 노드를 나타냅니다  
그리고 조건문에서 현재 최단경로와 중간 지점을 거쳐서 가는 경로를 비교해 더 짧은 경로가 있는지 확인합니다.