# 7. 프로세스 스케줄링 알고리즘

프로세스 스케줄링 알고리즘은 크게 비선점과 선점 두 가지로 구분됩니다.

## 1. 비선점

### 1.1 FCFS (First-Come, First-Served)
- **장점:**
   - 구현이 간단하고 이해하기 쉽습니다.
- **단점:**
   - 평균 대기시간이 길어질 수 있습니다.
   - 선입선출 방식이므로, 더 긴 작업이 먼저 도착하면 처리 시간이 길어집니다.

### 1.2 SJF (Shortest Job First)
- **장점:**
   - 평균 대기시간을 최소화합니다.
- **단점:**
   - 실행 시간을 정확히 예측하기 어려워, 예측 오차가 발생할 수 있습니다.
   - 긴 작업이 계속해서 작은 작업들에 의해 뒤로 밀리는 "스타베이션" 문제가 발생할 수 있습니다.

### 1.3 HRN (Highest Response Ratio Next)
- **장점:**
   - 대기 시간과 실행시간을 모두 고려하여 성능을 개선합니다.
- **단점:**
   - 구현이 복잡하며, 우선순위를 계산하는 과정에서 오버헤드가 발생할 수 있습니다.

## 2. 선점

### 2.1 Priority Scheduling
- **장점:**
   - 중요한 작업을 빠르게 처리할 수 있습니다.
- **단점:**
   - 무한 봉쇄 등의 문제로 우선순위 역전 현상이 발생할 수 있습니다.
   - 우선순위 설정에 따라 기아(Starvation) 문제가 발생할 수 있습니다.

### 2.2 Round Robin
- **장점:**
   - 모든 프로세스에게 공정한 할당을 제공합니다.
   - 응답 시간을 개선할 수 있습니다.
- **단점:**
   - 시간이나 타임 슬라이스 설정에 따라 성능이 크게 달라질 수 있습니다.
   - 프로세스의 실행시간이 다를 경우, 평균 대기시간이 증가할 수 있습니다.

### 2.3 Multi-level Queue Scheduling
- **장점:**
   - 다양한 우선순위와 작업 특성에 따라 효율적으로 프로세스를 관리할 수 있습니다.
- **단점:**
   - 큐 간의 전환에서 오버헤드가 발생할 수 있습니다.

### 2.4 Multi-level Feedback Queue Scheduling
- **장점:**
   - 프로세스의 특성에 따라 동적으로 큐를 이동하여 효과적으로 스케줄링이 가능합니다.
- **단점:**
   - 구현이 복잡하며, 적절한 파라미터 설정이 필요합니다.
   - 설정된 파라미터에 따라 성능이 크게 달라질 수 있습니다.

각 알고리즘은 특정 상황에 적합하며, 선택된 스케줄링 알고리즘이 시스템 성능에 미치는 영향을 고려하여 적절한 선택이 필요합니다.

---

# 8. 뮤텍스와 세마포어의 차이점

뮤텍스와 세마포어는 모두 동기화를 위한 기법으로 사용되지만, 몇 가지 중요한 차이가 있습니다.

1. **용어적 차이:**
   - 뮤텍스는 상호 배제(mutual exclusion)를 위한 동기화 기법으로, 특정 리소스에 대한 접근을 오직 하나의 스레드나 프로세스만이 허용합니다.
   - 세마포어는 뮤텍스의 일반화된 형태로, 특정 리소스에 대한 접근을 제어하고 동기화하기 위해 사용되며, 동시에 여러 개의 스레드가 접근할 수 있습니다.

2. **소유권과 관리:**
   - 뮤텍스는 소유할 수 있고, 뮤텍스를 소유한 스레드나 프로세스는 해당 뮤텍스의 소유주로 책임을 가집니다.
   - 세마포어는 소유할 수 없으며, 소유자 개념이 없습니다.

3. **동기화 대상 수:**
   - 세마포어는 동기화 대상이 여러 개일 때 사용됩니다. 여러 스레드가 동시에 리소스에 접근할 수 있고, 세마포어 값은 음수가 될 수 있습니다.
   - 뮤텍스는 동기화 대상이 오직 하나일 때 사용됩니다. 단일 뮤텍스를 소유한 스레드만이 임계 구역에 접근할 수 있습니다.

4. **초기값 설정:**
   - 세마포어는 초기값을 양수로 설정하여 여러 스레드가 동시에 리소스에 접근할 수 있는 허용 범위를 나타낼 수 있습니다.
   - 뮤텍스는 단순히 잠금/해제 상태만을 표현하므로 초기값이 필요하지 않습니다.

5. **동작 방식:**
   - 세마포어는 P(wait)와 V(signal) 연산을 통해 동작하며, P 연산은 리소스를 기다리다가 얻을 때까지 차단되고, V 연산은 리소스를 해제하고 대기 중인 스레드를 깨울 때 사용됩니다.
   - 뮤텍스는 락(lock)과 언락(unlock) 연산을 통해 동작하며, 락 연산은 뮤텍스를 확보하고 다른 스레드가 접근하지 못하도록 막는 것이고, 언락 연산은 뮤텍스를 해제하여 다른 스레드가 접근할 수 있게 합니다.
---

# 9. Deadlock에 대한 설명

**1. 개념:**
- Deadlock은 둘 이상의 프로세스가 특정 조건에서 상호 작용하며 무한정 기다리는 상황을 의미합니다.

**2. 발생 조건:**
1. **상호배제 (Mutual Exclusion):** 리소스에 대한 배타적인 통제가 필요한 상황에서 발생합니다.
2. **점유와 대기 (Hold and Wait):** 프로세스가 어떤 리소스를 보유하고 있으면서 다른 프로세스가 필요한 리소스를 기다릴 때 발생합니다.
3. **비선점 (No Preemption):** 다른 프로세스에 의해 리소스를 강제로 뺏을 수 없는 상황에서 발생합니다.
4. **환형 대기 (Circular Wait):** 프로세스 집합이 서로를 기다리는 순환 구조를 이룰 때 발생합니다.

**3. 해결 방안:**
1. **예방 (Prevention):**
    - 사전에 시스템을 제어하는 방법으로, 발생 조건 중 어느 하나를 제거하여 예방합니다.
    - 자원 낭비가 가장 심한 해결 방법이지만, 안전성을 보장합니다.

2. **회피 (Avoidance):**
    - Deadlock 발생 가능성을 배제하지 않고, 발생 시 적절히 피해나가는 방법입니다.
    - **은행원 알고리즘 (Banker's Algorithm):** 리소스 할당이 안전한지 미리 검사하여 안전한 경우에만 할당을 진행합니다.
    - **자원 할당 그래프 알고리즘:** 자원과 프로세스 간의 관계를 그래프로 표현하고, 사이클이 없는 경우에만 자원을 할당합니다.